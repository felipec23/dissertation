import streamlit as st

# Has to be done here, bc it's the first thing that needs to be done
st.set_page_config(page_title="Open Science", page_icon="ðŸ”¬", layout="wide", initial_sidebar_state="expanded")

from sidebar_code import sidebar_code
import os
from dotenv import load_dotenv
from utils_functions import *
import pandas as pd


load_dotenv()

st.title("Open Science")


COLLECTION_NAME = os.getenv("TYPESENSE_COLLECTION_NAME")

print("Collection name: ", COLLECTION_NAME)



N_cards_per_row = 1

# Create the sidebar
sidebar_code()

# Load the Typesense client
client = load_typesense_client()

# Create a container for the search bar
search_container = st.container()




# Setting state variables   

if 'current_page' not in st.session_state:
    st.session_state.current_page = 1

# Setting if its new query, for diferentiating between new query and pagination
if 'new_query' not in st.session_state:
    print("Setting new query to True")
    st.session_state['new_query'] = True

# Same for total pages
if 'total_pages' not in st.session_state:
    print("Setting total pages to 1")
    st.session_state['total_pages'] = 1

# Response
if 'response' not in st.session_state:
    print("Setting response to empty")
    st.session_state['response'] = ""

# Add search input to state so that the page don't lose the content when the user changes between pages
if 'search_input' not in st.session_state:
    print("Setting search input to empty")
    st.session_state['search_input'] = ""

# Add a variable to keep track of the last page the user was in
if 'last_page' not in st.session_state:
    print("Setting last page to 1")
    st.session_state['last_page'] = 'papers'


# Results container
# if 'results_container' not in st.session_state:
#     print("Setting results container to empty")
#     st.session_state['results_container'] = results_container


def display_results():
    
    # results_container = st.session_state.results_container
    N_cards_per_row=1
    response = st.session_state.response

    print("Displaying response")
    with results_container:
        # for n_row, row in df_search.reset_index().iterrows():
        for n_row, items in enumerate(response["hits"]):
            
            dictionary = items["document"]


            i = n_row%N_cards_per_row
            if i==0:
                st.write("---")
                cols = st.columns(N_cards_per_row, gap="large")
            # draw the card
            with cols[n_row%N_cards_per_row]:
                
                title = dictionary['title'].replace("\n", " ") if "title" in dictionary else ""
                # st.subheader(f"{title}", anchor=f"{dictionary['url']}")
                string = 'a:hover {color: blue;}'
                st.markdown(f"""
    <h3 style='color: black';{string} ><a href='{dictionary['link']}' style='text-decoration:none;color:black; hover:color:blue'>{title}</a></h3>
""", unsafe_allow_html=True)
                st.markdown(f"*{dictionary['authors']}*")


                if dictionary['predictions'] != "":


                    list_of_tags = dictionary['predictions']

                    # Now, to each element of the list of tags, put a nice background, add a bit of padding and a border radius
                    # list_of_tags = [f"<span style='background-color: #F5F5F5; margin-right: 5px; padding: 0.2rem 0.5rem; border-radius: 5px;'>{  tag  }</span>" for tag in list_of_tags]

                    # Now, to each element of the list of tags, put a nice background, add a bit of padding and a border radius, and a bit of margin up and down
                    list_of_tags = [f"<span style='      display: inline-block; background-color: #e0e0e0; padding: 5px 10px; border-radius: 5px; margin-bottom: 5px; margin-top: 2px; margin-right: 5px;'>{  tag  }</span>" for tag in list_of_tags]
                    # Join the list of tags into a string
                    list_of_tags = " ".join(list_of_tags)

                    # Now, we can use the markdown component to show the list of tags
                    st.markdown(list_of_tags, unsafe_allow_html=True)


                # Component for date:
                # Convert date from unix to string of the format month, year

                # date_string = datetime.fromtimestamp(dictionary['publishedDate']).strftime("%B, %Y")
                date_string = dictionary['date']
                st.markdown(f"**{date_string}**")

                with st.expander("See abstract"):
                    st.caption(f"{dictionary['abstract']} ")

        
        st.write("---")




if st.session_state.search_engine == "By papers":

    st.caption(
        """Here you can search by papers, just as you would do in Google Scholar.
        You will see that each result/paper has some tags attached to it. These tags were generated by the AI model and they
        are the quantities present in the abstract. Each tag is divided in 3 parts: the name of the variable detected, the value and the unit.
        """)


    # Create a text input for the search bar
    search_input_text = st.text_input(
        "Search by abstract", 
        # value="", 
        key="search_input_text", 
        on_change=set_page_to_1,
        placeholder='machine learning in cancer'
        # placeholder=st.session_state.placeholder
        )
    
    # Create a container for the results
    results_container = st.container()
    
    if search_input_text != "":
        st.session_state.search_input = search_input_text
        print("Search session state updated: ", st.session_state.search_input)

    # Search by papers
    if search_input_text != "" and st.session_state['new_query']:

        search_config_papers = {
            'q': search_input_text,
            'query_by': 'title,abstract'
        }
        
        response = make_request_to_typesense(search_config_papers)

        st.session_state['response'] = response

        print("Over here")

    if st.session_state['response'] != "":

        
        # Display the results
        display_results()

        # Scroll to the top of the page
        scroll_if_needed()

        # Encontrados
        found = st.session_state['response']['found']

        # Number of pages
        N_pages = found // 10
        # Saving to states
        st.session_state['total_pages'] = N_pages


        # Display the pagination component
        # bottom_menu = st.columns((4, 1, 1))
        bottom_menu = st.columns(10)


        cp = st.session_state['current_page']
        tp = st.session_state['total_pages']

        if tp == 0:
            tp = 1


        with bottom_menu[8]:
            previous = st.button("Previous page" if cp > 1 else "First page", on_click=run_previous_page, disabled=cp == 1)


        with bottom_menu[9]:
            next = st.button("Next page" if cp < tp else "Last page", on_click=run_next_page, disabled=cp == tp)


        with bottom_menu[0]:
            st.markdown(f"Page **{cp}** of **{tp}** ")

        print("\n")

    st.session_state.last_page = 'papers'



else: 

    
    # Search by variables
    search_container.caption("""Here, instead of searching for papers, you can search for variables. 
                             These variables are the ones that the AI model detected in the abstracts.
                             An example is the variable "F1 score", which is a metric used to evaluate the performance of a model in machine learning,
                             or "tensile strength", which is a mechanical property of materials, or "temperature", which is a physical quantity.
                             """)

    # Create a text input for the search bar
    search_input_vars = search_container.text_input(
        "Type here the variable name. If you want to get an exact match, please wrap the terms in double quotations.", 
        value="", 
        key="search_input_vars",
        placeholder='F1 score')

    print("Search input vars: ", search_input_vars)
    # Checkbox to allow advanced search
    # advanced_search = search_container.checkbox("Advanced search", value=False, key="advanced_search")

    # Create a dictionary with the search config
    if '"' in search_input_vars:
        exact_search = True
    else:
        exact_search = False

    # Set up searh config
    search_config = {
        'q': search_input_vars.replace('"', ''),
        'query_by': 'predictions',
        'page': 1,
        'per_page': 200
    }

    config = ""

    # if advanced_search:

    # Text to exlcude words from the variable name
    search_exclude = search_container.text_input("If you'd like to exclude words from the variable name, add them here separated by commas:", value="", key="search_exclude")

    if search_exclude != "":
        words_list = search_exclude.split(",")
        for word in words_list:
            search_config['q'] = search_config['q'] + " -" + word.strip()

    # Box to check if the user also wants to search by abstract
    search_abstract = search_container.text_input(
        "Write here some keywords you want the abstract to have", 
        value="", 
        key="search_abstract",
        placeholder="cancer")

    if search_abstract != "":
        # search_config['query_by'] = search_config['query_by'] + ",abstract"
        # search_config['q'] = search_config['q'] + " " + search_abstract
        search_config['filter_by'] = "abstract:{}".format(search_abstract)


    # Concatenate all parameters in a string
    config = search_input_vars + search_exclude + search_abstract

    print('String config: ', config)

    # Text to exlcude words from the abstract
    # search_exclude_abstract = search_container.text_input("Exclude words from the abstract", value="", key="search_exclude_abstract")


    
    if search_input_vars != "":

        print("Search config: ", search_config)

        df = perform_query(search_config)


        # Add separator
        st.divider()


        # df.drop("id", axis=1, inplace=True)

        st.header("Results")

        if df.shape[0] == 0:
            st.markdown("No results were found for your search. Please, try again.")
            st.stop()
        st.markdown("The following table shows the results of your search. You can sort the results by clicking on the 'value' column.")

      

        # st.write(df_numbers["variable"].values.tolist())
        if exact_search:
            filtro = search_input_vars.replace('"', '')
            print("Filtro:", filtro)

            # Apply filter, both for lowercase and uppercase
            df = df[df["variable"].isin([filtro, filtro.lower()])]
            # df = df[df["variable"] == filtro]

        # Create form:
        checkbox = st.checkbox("Parse values as numeric", value=True, key="parse_values_checkbox")

        list_of_units = df["unit"].unique().tolist()
        list_of_units.insert(0, "All units")
        filter_by_unit = st.multiselect("Keep only results that have these units", options=list_of_units, default=list_of_units[0], key="filter_by_unit")
        # Display the results
        if not checkbox:
            st.caption("A total of {} results were found.".format(df.shape[0]))

            # Apply filter by unit
            if "All units" not in filter_by_unit:
                df = df[df["unit"].isin(filter_by_unit)]

            st.dataframe(df, use_container_width=True, hide_index=True)
        else:
            df_numbers = df.copy()

            # Set value column as float, if error, remove the row
            df_numbers["value"] = pd.to_numeric(df_numbers["value"], errors='coerce')

            # Remove rows with NaN
            df_numbers.dropna(subset=["value"], inplace=True)

            # Sort by value
            df_numbers.sort_values(by=["value"], inplace=True, ascending=False)

            # Apply filter by unit
            if "All units" not in filter_by_unit:
                df_numbers = df_numbers[df_numbers["unit"].isin(filter_by_unit)]

            # Display the results
            st.caption("A total of {} results were found.".format(df_numbers.shape[0]))
            st.dataframe(df_numbers, use_container_width=True, hide_index=True)

            with st.expander("See statistics"):
                statistics = df_numbers.describe()
                # Change index name
                statistics.rename(index={"count": "Number of values found", 
                                         "mean": "Mean", 
                                         "std": "Standard deviation", 
                                         "min": "Minimum", "25%": "25th percentile", 
                                         "50%": "50th percentile", 
                                         "75%": "75th percentile", 
                                         "max": "Maximum"}, inplace=True)
                st.dataframe(statistics, use_container_width=True)

    
    st.session_state.last_page = 'variables'